--- !ruby/object:RI::ClassDescription 
attributes: 
- !ruby/object:RI::Attribute 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: This is create identifier, that is used to decide, if the <em>json_create</em> hook of a class should be called. It defaults to 'json_class'.
  name: create_id
  rw: RW
- !ruby/object:RI::Attribute 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: Returns the JSON generator modul, that is used by JSON. This might be either JSON::Ext::Generator or JSON::Pure::Generator.
  name: generator
  rw: R
- !ruby/object:RI::Attribute 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: Returns the JSON parser class, that is used by JSON. This might be either JSON::Ext::Parser or JSON::Pure::Parser.
  name: parser
  rw: R
- !ruby/object:RI::Attribute 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: Returns the JSON generator state class, that is used by JSON. This might be either JSON::Ext::Generator::State or JSON::Pure::Generator::State.
  name: state
  rw: RW
class_methods: 
- !ruby/object:RI::MethodSummary 
  name: "[]"
comment: 
- !ruby/struct:SM::Flow::H 
  level: 1
  text: json - JSON for Ruby
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Description
- !ruby/struct:SM::Flow::P 
  body: "This is a implementation of the JSON specification according to RFC 4627 (http://www.ietf.org/rfc/rfc4627.txt). Starting from version 1.0.0 on there will be two variants available:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: A pure ruby variant, that relies on the iconv and the stringscan extensions, which are both part of the ruby standard library.
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: The quite a bit faster C extension variant, which is in parts implemented in C and comes with its own unicode conversion functions and a parser generated by the ragel state machine compiler (http://www.cs.queensu.ca/~thurston/ragel).
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: Both variants of the JSON generator escape all non-ASCII an control characters with \uXXXX escape sequences, and support UTF-16 surrogate pairs in order to be able to generate the whole range of unicode code points. This means that generated JSON text is encoded as UTF-8 (because ASCII is a subset of UTF-8) and at the same time avoids decoding problems for receiving endpoints, that don't expect UTF-8 encoded texts. On the negative side this may lead to a bit longer strings than necessarry.
- !ruby/struct:SM::Flow::P 
  body: All strings, that are to be encoded as JSON strings, should be UTF-8 byte sequences on the Ruby side. To encode raw binary strings, that aren't UTF-8 encoded, please use the to_json_raw_object method of String (which produces an object, that contains a byte array) and decode the result on the receiving endpoint.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Author
- !ruby/struct:SM::Flow::P 
  body: Florian Frank &lt;mailto:flori@ping.de&gt;
- !ruby/struct:SM::Flow::H 
  level: 2
  text: License
- !ruby/struct:SM::Flow::P 
  body: This software is distributed under the same license as Ruby itself, see http://www.ruby-lang.org/en/LICENSE.txt.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Download
- !ruby/struct:SM::Flow::P 
  body: The latest version of this library can be downloaded at
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: http://rubyforge.org/frs?group_id=953
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: Online Documentation should be located at
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: http://json.rubyforge.org
  type: :BULLET
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Speed Comparisons
- !ruby/struct:SM::Flow::P 
  body: "I have created some benchmark results (see the benchmarks subdir of the package) for the JSON-Parser to estimate the speed up in the C extension:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "JSON::Pure::Parser:"
    body: 28.90 calls/second
  - !ruby/struct:SM::Flow::LI 
    label: "JSON::Ext::Parser:"
    body: 505.50 calls/second
  type: :NOTE
- !ruby/struct:SM::Flow::P 
  body: This is ca. <b>17.5</b> times the speed of the pure Ruby implementation.
- !ruby/struct:SM::Flow::P 
  body: "I have benchmarked the JSON-Generator as well. This generates a few more values, because there are different modes, that also influence the achieved speed:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "JSON::Pure::Generator:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "generate:"
      body: 35.06 calls/second
    - !ruby/struct:SM::Flow::LI 
      label: "pretty_generate:"
      body: 34.00 calls/second
    - !ruby/struct:SM::Flow::LI 
      label: "fast_generate:"
      body: 41.06 calls/second
    type: :NOTE
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "JSON::Ext::Generator:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "generate:"
      body: 492.11 calls/second
    - !ruby/struct:SM::Flow::LI 
      label: "pretty_generate:"
      body: 348.85 calls/second
    - !ruby/struct:SM::Flow::LI 
      label: "fast_generate:"
      body: 541.60 calls/second
    type: :NOTE
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "Speedup Ext/Pure:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "generate safe:"
      body: 14.0 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate pretty:"
      body: 10.3 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate fast:"
      body: 13.2 times
    type: :NOTE
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: "The rails framework includes a generator as well, also it seems to be rather slow: I measured only 23.87 calls/second which is slower than any of my pure generator results. Here a comparison of the different speedups with the Rails measurement as the divisor:"
- !ruby/object:SM::Flow::LIST 
  contents: 
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "Speedup Pure/Rails:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "generate safe:"
      body: 1.5 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate pretty:"
      body: 1.4 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate fast:"
      body: 1.7 times
    type: :NOTE
  - !ruby/struct:SM::Flow::LI 
    label: "*"
    body: "Speedup Ext/Rails:"
  - !ruby/object:SM::Flow::LIST 
    contents: 
    - !ruby/struct:SM::Flow::LI 
      label: "generate safe:"
      body: 20.6 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate pretty:"
      body: 14.6 times
    - !ruby/struct:SM::Flow::LI 
      label: "generate fast:"
      body: 22.7 times
    type: :NOTE
  type: :BULLET
- !ruby/struct:SM::Flow::P 
  body: To achieve the fastest JSON text output, you can use the fast_generate/fast_unparse methods. Beware, that this will disable the checking for circular Ruby data structures, which may cause JSON to go into an infinite loop.
- !ruby/struct:SM::Flow::H 
  level: 2
  text: Examples
- !ruby/struct:SM::Flow::P 
  body: "To create a JSON text from a ruby data structure, you can call JSON.generate (or JSON.unparse) like that:"
- !ruby/struct:SM::Flow::VERB 
  body: " json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]\n # =&gt; &quot;[1,2,{\\&quot;a\\&quot;:3.141},false,true,null,\\&quot;4..10\\&quot;]&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: "It's also possible to call the #to_json method directly."
- !ruby/struct:SM::Flow::VERB 
  body: " json = [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10].to_json\n # =&gt; &quot;[1,2,{\\&quot;a\\&quot;:3.141},false,true,null,\\&quot;4..10\\&quot;]&quot;\n"
- !ruby/struct:SM::Flow::P 
  body: To create a valid JSON text you have to make sure, that the output is embedded in either a JSON array [] or a JSON object {}. The easiest way to do this, is by putting your values in a Ruby Array or Hash instance.
- !ruby/struct:SM::Flow::P 
  body: "To get back a ruby data structure from a JSON text, you have to call JSON.parse on it:"
- !ruby/struct:SM::Flow::VERB 
  body: " JSON.parse json\n # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, &quot;4..10&quot;]\n"
- !ruby/struct:SM::Flow::P 
  body: "Note, that the range from the original data structure is a simple string now. The reason for this is, that JSON doesn't support ranges or arbitrary classes. In this case the json library falls back to call Object#to_json, which is the same as #to_s.to_json."
- !ruby/struct:SM::Flow::P 
  body: "It's possible to extend JSON to support serialization of arbitrary classes by simply implementing a more specialized version of the #to_json method, that should return a JSON object (a hash converted to JSON with #to_json) like this (don't forget the *a for all the arguments):"
- !ruby/struct:SM::Flow::VERB 
  body: " class Range\n   def to_json(*a)\n     {\n       'json_class'   =&gt; self.class.name, # = 'Range'\n       'data'         =&gt; [ first, last, exclude_end? ]\n     }.to_json(*a)\n   end\n end\n"
- !ruby/struct:SM::Flow::P 
  body: The hash key 'json_class' is the class, that will be asked to deserialize the JSON representation later. In this case it's 'Range', but any namespace of the form 'A::B' or '::A::B' will do. All other keys are arbitrary and can be used to store the necessary data to configure the object to be deserialized.
- !ruby/struct:SM::Flow::P 
  body: "If a the key 'json_class' is found in a JSON object, the JSON parser checks if the given class responds to the json_create class method. If so, it is called with the JSON object converted to a Ruby hash. So a range can be deserialized by implementing Range.json_create like this:"
- !ruby/struct:SM::Flow::VERB 
  body: " class Range\n   def self.json_create(o)\n     new(*o['data'])\n   end\n end\n"
- !ruby/struct:SM::Flow::P 
  body: "Now it possible to serialize/deserialize ranges as well:"
- !ruby/struct:SM::Flow::VERB 
  body: " json = JSON.generate [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]\n # =&gt; &quot;[1,2,{\\&quot;a\\&quot;:3.141},false,true,null,{\\&quot;json_class\\&quot;:\\&quot;Range\\&quot;,\\&quot;data\\&quot;:[4,10,false]}]&quot;\n JSON.parse json\n # =&gt; [1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10]\n"
- !ruby/struct:SM::Flow::P 
  body: "JSON.generate always creates the shortest possible string representation of a ruby data structure in one line. This good for data storage or network protocols, but not so good for humans to read. Fortunately there's also JSON.pretty_generate (or JSON.pretty_generate) that creates a more readable output:"
- !ruby/struct:SM::Flow::VERB 
  body: " puts JSON.pretty_generate([1, 2, {&quot;a&quot;=&gt;3.141}, false, true, nil, 4..10])\n [\n   1,\n   2,\n   {\n     &quot;a&quot;: 3.141\n   },\n   false,\n   true,\n   null,\n   {\n     &quot;json_class&quot;: &quot;Range&quot;,\n     &quot;data&quot;: [\n       4,\n       10,\n       false\n     ]\n   }\n ]\n"
- !ruby/struct:SM::Flow::P 
  body: There are also the methods Kernel#j for unparse, and Kernel#jj for pretty_unparse output to the console, that work analogous to Core Ruby's p and the pp library's pp methods.
- !ruby/struct:SM::Flow::P 
  body: The script tools/server.rb contains a small example if you want to test, how receiving a JSON object from a webrick server in your browser with the javasript prototype library (http://www.prototypejs.org) works.
constants: 
- !ruby/object:RI::Constant 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: For backwards compatibility
  name: UnparserError
  value: GeneratorError
- !ruby/object:RI::Constant 
  comment: 
  - !ruby/struct:SM::Flow::P 
    body: JSON version
  name: VERSION
  value: "'1.1.0'"
- !ruby/object:RI::Constant 
  comment: 
  name: VARIANT_BINARY
  value: "false"
full_name: JSON
includes: []

instance_methods: 
- !ruby/object:RI::MethodSummary 
  name: fast_generate
- !ruby/object:RI::MethodSummary 
  name: fast_unparse
- !ruby/object:RI::MethodSummary 
  name: generate
- !ruby/object:RI::MethodSummary 
  name: parse
- !ruby/object:RI::MethodSummary 
  name: pretty_generate
- !ruby/object:RI::MethodSummary 
  name: pretty_unparse
- !ruby/object:RI::MethodSummary 
  name: unparse
name: JSON
superclass: 
